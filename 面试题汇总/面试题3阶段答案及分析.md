# 第一题

```

-1、let/const
1)let不存在变量声明提升
2）let不允许重复声明
3）全局作用域中let声明的变量和window没有映射关系
4）typeof未被声明的变量 =>结果是报错不是undefined（暂时性死区）
5)形成块级作用域
-2、解构赋值
-3、“...”拓展运算符
-4、箭头函数
1）没有arguments，...arg获取实参集合
2）没有自己的this，this是上下文中的this
-5、模板字符串
-6、Promise（async/await）
-7、class
-8、interator（for of 循环）
-9、Map /	Set

```

# 第二题

1、浏览器渲染页面4步

2、重绘：不改变位置和大小的情况下，改变样式 ----重新加载RENDER TREE

3、重排：改变大小和位置	----	重新加载DOM TREE

4、缺点：不论是重排还是重绘都非常耗费性能

5、解决方案：减少DOM操作

​	1)把需要增加的元素拼接成字符串，最后统一进行增加

​	2）读写分离：把统一样式放到一起执行，新版浏览器有一个检测机制，会把修改样式的操作存起来，直到遇到非修改样式的操作，会把之前存储的统一执行，引发一次回流和重绘

```
浏览器渲染页面时，
“先创建DOM树->再加载CSS->生成渲染树RENDER TREE->把渲染树交给浏览器进行绘制”，
如果后期修改元素的样式（没有改变大小和位置），浏览器会把当前元素重新渲染生成渲染树，重新渲染，这个机制是---重绘，
如果元素的位置和大小发生改变，浏览器就要从DOM树重新计算渲染

```


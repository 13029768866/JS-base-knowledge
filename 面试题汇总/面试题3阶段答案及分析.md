# 第一题

```

-1、let/const
1)let不存在变量声明提升
2）let不允许重复声明
3）全局作用域中let声明的变量和window没有映射关系
4）typeof未被声明的变量 =>结果是报错不是undefined（暂时性死区）
5)形成块级作用域
-2、解构赋值
-3、“...”拓展运算符
-4、箭头函数
1）没有arguments，...arg获取实参集合
2）没有自己的this，this是上下文中的this
-5、模板字符串
-6、Promise（async/await）
-7、class
-8、interator（for of 循环）
-9、Map /	Set

```

# 第二题

1、浏览器渲染页面4步

2、重绘：不改变位置和大小的情况下，改变样式 ----重新加载RENDER TREE

3、重排：改变大小和位置	----	重新加载DOM TREE

4、缺点：不论是重排还是重绘都非常耗费性能

5、解决方案：减少DOM操作

​	1)把需要增加的元素拼接成字符串，最后统一进行增加

​	2）读写分离：把统一样式放到一起执行，新版浏览器有一个检测机制，会把修改样式的操作存起来，直到遇到非修改样式的操作，会把之前存储的统一执行，引发一次回流和重绘

```
浏览器渲染页面时，
“先创建DOM树->再加载CSS->生成渲染树RENDER TREE->把渲染树交给浏览器进行绘制”，
如果后期修改元素的样式（没有改变大小和位置），浏览器会把当前元素重新渲染生成渲染树，重新渲染，这个机制是---重绘，
如果元素的位置和大小发生改变，浏览器就要从DOM树重新计算渲染

```

# 第三题

=>	答案：number

```
1、NaN ！= NaN
2、parseFloat遇见非数字返回NaN
3、 typeof NaN == ’number‘
```

# 第四题

=>	abc123456,

​	333,

​	字符串“1”

```
1、+字符串拼接
2、“-”数学运算
3、alert输出字符串“1”
```

# 第五题

=>	答案：

let reg= /^[0-9a-zA-Z]{2|20}$/

# 第六题

JS本身就是基于面向对象（OOP）编程思想开发出来的语言，

数组是Array的实例，对象是Object实例，函数Function实例，这些内置类的原型上有很多公共属性和方法可以被实例调用

基于class或者function创建一个类，执行的时候new创建一个实例，类的继承，封装，多态。

封装：提取公共方法

多态：JS中没有严格意义的多态，不能进行方法的重写

继承：原型继承，call继承，寄生组合继承，es6中的继承，项目中都是基于class和extend实现继承

# 第七题

=> 10 , 

​      20

```
函数执行this指向window
```

# 第八题

=>  答案：10，

​		  30

```
方法执行看“.”前面的是谁
```

# 第九题

=> 答案：8，11 ,  2

# 第十题

当前作用域没有的变量，会根据作用域链向上查找，只到找到全局的window为止。

原型链：画图分析，讲解。